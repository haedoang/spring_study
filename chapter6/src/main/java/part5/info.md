### 스프링 AOP[⭐⭐⭐⭐⭐️️️]

#### 자동 프록시 생성
- 부가기능의 적용이 필요한 타깃 오브젝트마다 비슷한 내용의 `proxyFactoryBean` 빈 설정정보를 추가해주어야 한다
  ```text
     //서비스가 늘어난다면 아래와 같은 설정 정보를 추가로 작성해주어야 한다
     <bean id="userService" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="target" ref="userServiceImpl"/>
        <!-- advisors -->
        <property name="interceptorNames">
            <list>
                <value>transactionAdvisor</value>
            </list>
        </property>
    </bean>  
  ```
- 현재까지 중복에 대한 문제를 처리했던 방법들
  - JDBC DAO 코드의 JDBC 코드 중복 발생: 템플릿과 콜백, 클라이언트로 나누어 해결. 전략패턴과 DI 적용
  - 부가기능 반복적인 위임 코드가 발생: 다이나믹 프록시의 런타임 코드 자동 생성 기법 사용
  - ProxyFactoryBean을 통해 생성되는 프록시를 지동화 할 수 있는 방법은 무엇인가..

#### 빈 후처리기를 이용한 자동 프록시 생성기
- `BeanPostProcessor` 인터페이스: 스프링 빈 오브젝트를 만들어지고 난 후에, 빈 오브젝트를 가공할 수 있게 해준다.
- `DefaultAdvisorAutoProxyCreator`: 어드바이저를 이용한 자동 프록시 생성기. 빈으로 등록해야 한다
- 스프링은 빈 후처리기가 빈으로 등록되어 있는 경우 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 작업을 요청한다
- 빈 후처리기의 기능 
  - 빈 오브젝트의 프로퍼티를 강제로 수정할 수 있다
  - 별도의 초기화 작업을 수행할 수 있다
  - 만들어진 빈 오브젝트 자체를 바꿔치기할 수 있다
  - 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고 프록시를 빈으로 대신 등록할 수 있다
- 빈 후처리기 동작 방식
  - 빈 오브젝트가 만들어질 때마다 빈 후처리기로 보낸다
  - `DefaultAdvisorAutoProxyCreator`는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시대상인지 확인한다
  - 프록시 대상인 경우 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시를 어드바이저에 연결해준다
  - 프록시가 생성되면 우너래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 돌려준다
  - 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다
  ```text
                               (생성된 빈)          (대상 확인) (포인트컷/어드바이스)
    빈 설정 파일 ---> 빈 오브젝트 생성 ------>  빈 후처리기 ------->    어드바이저
                                   (생성된 빈)  |                   ↑
                                             /  ↘                 |   
                          빈 생성완료/사용     ↙       프록시 생성기  ----︎
  ```

#### 확장된 포인트컷 
- 포인트컷 인터페이스 기능
  - 프록시를 적용할 클래스인지 확인한다
  - 어드바이스를 적용할 메서드인지를 확인한다
  ```java
  public interface Pointcut {
      ClassFilter getClassFilter();
      MethodMatcher getMethodMatcher();
  }
  ```
  - 프록시를 적용할 클래스인지 판단하고나서, 적용대상 클래스인 경우 어드바이스를 적용할 메서드인지 확인한다

#### DefaultAdvisorAutoProxyCreator 
- 적용할 자동 프록시 생성기. 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다
- 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보면서 프록시 적용 대상을 선정한다 
- 빈 클래스가 프록시 선정 대상이라면 프록시를 만들어 원래 빈 오븢게트와 바꿔치기한다
  ```xml
  <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>
  ```

#### 포인트컷 표현식을 이용한 포인트컷
- 포인트컷 표현식: `AspectJExpressionPointcut` 클래스를 사용해야 한다.
- 표현식 문법 
  > execution([접근제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...)[throws 예외 패턴])
  - 접근제한자: 생략 가능. 조건 부여하지 않음
  - 리턴 타입: 필수. `*`: 전체
  - 패키지.클래스명: 생략 가능. 패키지와 클래스 또는 인터페이스 이름에 `*` 사용 가능, `..` 여러 개의 패키지 선택 가능
  - 메서드명: 필수. `*`: 전체
  - 메서드 아규먼트: 필수. `(..)`: 전체
  - 예외: 생략 가능.

#### 포인트컷 표현식을 이용하는 포인트컷 적용
- 런타임 시점까지 문법의 검증이나 기능 확인이 되지 않는 단점이 있다
  ```xml
  <bean id="transactionPointcut" class="org.springframework.aop.aspectj.AspectJExpressionPointcut">-->
      <property name="expression" value="execution(* *..*ServiceImpl.upgrade*(..))"/>
  </bean>
  ```
#### 타입 패턴과 클래스 이름 패턴
- 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 `타입` 패턴이다.
- 따라서 인터페이스를 구현하고 있다면, 해당 인터페이스 타입으로 지정할 경우 하위 구현체 모두 타깃 빈이 된다

--- 

### AOP란 무엇인가
 
#### 트랜잭션 서비스 추상화
- 트랜잭션 경계설정 코드를 비즈니스 로직에 담을 경우 특정 트랜잭션 기술에 종속되는 코드가 될 수 있다(JPA, JDBC...)
- 위와 같은 문제는 `서비스 추상화 기법`을 적용하여 인터페이스와 DI를 통해 해결할 수 있다

#### 프록시와 데코레이터 패턴
- 트랜잭션을 추상화를 통해 제거했지만, 여전히 브지늣 로직 코드에는 트랜잭션을 적용하고 있다
- `DI를 통한 데코레이터`패턴을 사용하여 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃 접근하는 방식으로 분리할 수 있었다.
- 또한, 고립된 단위 테스트를 만들 수 있다

#### 다이내믹 프록시와 프록시 팩토리 빈
- 비즈니스 로직 인터페이스의 모든 메서드 마다 트랜잭션 기능을 부여하는 코드가 들어가게 되는 문제가 발생하였다
- 트랜잭션이 필요 없는 메서드조차 구현이 필요하였다
- 프록시 클래스 없이도 프록시 오브젝트를 런타임 시 만들어주는 `JDK 다이내믹 프록시 기술`을 사용하여 프록시 클래스 코드 작성의 부담을 줄일 수 있다
- 또한, 부가 기능 부여 코드의 중복 문제도 해결할 수 있다.
- 하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 중복 문제가 발생하였다
- 스프링의 `프록시 팩토리 빈` 을 이용하여 템플릿/콜백 패턴을 사용하여 어드바이스와 포인트컷을 프록시와 분리하여 여러 프록시와 공유할 수 있다

#### 자동 프록시 생성방법과 포인트 컷
- 트랜잭션 적용 대상이 되는 빈 마다 프록시 팩터리 빈을 설정해줘야하는 부담이 생겼다
- 스프링 컨테이너 `빈 생성 후처리 기법` 을 활용해 프록시 적용 대상을 일괄적으로 처리할 수 있다

#### 부가기능 모듈화 
- 부가기능을 간단하게 분리해서 독립된 모듈로 만들기란 쉽지 않다(다이내믹 프록시, IoC/DI 컨테이너의 빈 후처리 기술과 같은 복잡한 기술이 요구됨)
- DI, 데코레이터 패턴, 다이나믹 프록시, 오브젝트 생성 후처리, 자동 프록시 생성, 포인트컷과 같은 기법이 위와 같은 문제를 해결하기 위한 대표적인 방법이다

#### AOP: 애스펙트 지향 프로그래밍
- 부가기능 모듈을 말한다
- 부가될 기능을 정의한 코드인 어드바이스, 어드바이스를 적용할 포인트컷을 가지고 있다
- 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스팩트라는 독특한 모듈로 만들어 설계하고 개발하는 방법을 `애스팩트 지향 프로그래밍` 이라 한다
- AOP는 애스팩트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것이다 

---
### AOP 적용 기술

#### 프록시를 이용한 AOP
- `MethodInterceptor`, `InvocationHandler` 대표적인 프록시를 이용한 AOP 방식이다

#### 바이트코드 생성과 조작을 통한 AOP
- AspectJ는 바이트코드를 변경해서 AOP 기술을 사용한다
  - 스프링과 같이 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있다
  - 프록시 방식은 메서드 단위에서만 기술적용이 가능한 반면, 바이트코드를 조작하는 경우 오브젝트 생성, 필드 값의 조회, 조작, 스태틱 초기화 등 다양한 작업에 기능을 부가할 수 있다

---
### AOP 용어

#### 타깃
- 부가기능을 부여할 대상이다

#### 어드바이스
- 타깃에게 제공할 부가기능을 담은 모듈이다

#### 조인포인트
- 어드바이스가 적용될 수 있는 위치를 말한다. 스프링의 프록시 AOP는 메서드 실행 단계 뿐이다

#### 포인트컷
- 어드바이스를 적용할 조인포인트를 선별하는 작업 또는 그 기능을 정의한 모듈을 말한다 
- 메서드를 선정하는 기능을 갖고 있다

#### 프록시
- 클라이언트와 타깃 사이에 투명하게 존재하며 부가 기능을 제공한다

#### 어드바이저
- 포인트컷과 어드바이스를 하나씩 가지고 있는 오브젝트이다
- 어떤 부가기능(어드바이스)를 어디에(포인트컷)에 전달할 것인가를 알고 있는 AOP의 기본이 되는 모듈이다

#### 애스팩트
- AOP의 기본 모듈이다. 싱글톤 형태로 존재한다

---
### AOP 네임스페이스
- 아래의 빈을 모두 등록해야 한다
  - 자동 프록시 생성기: `DefaultAdvisorAutoProxyCreator`
  - 어드바이스: 부가 기능. 직접 구현
  - 포인트컷: `AspectJExpressionPointcut`
  - 어드바이저: `DefaultPointcutAdvisor`

#### 어드바이저 내장 포인트컷 
  ```xml
  <aop:config>
    <aop:advisor advice-ref="transactionAdvice" pointcut="execution(* *..*ServiceImpl.upgrade*(..))"/>
  </aop:config>
```