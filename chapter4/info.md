### 정리


#### Spring JdbcTemplate 메서드 사용 시 SqlException이 없는 이유 
- SQLException은 복구할 수 없는 예외이다 
- 그래서 Spring에서는 템플릿과 콜백 내에서 발생하는 모든 SqlException을 런타임 예외인 `DataAccessException` 포장해서 던져준다
- 꼭 필요한 경우라면 `DataAccessException`을 예외로 잡아서 처리하면 된다


#### Exception 
- 체크 예외: (!RuntimeException) 서브 클래스
  - 반드시 예외를 처리하는 코드를 작성해야 한다
- 언 체크 예외: RuntimeException 서브 클래스
  - `NullPointException`, `IllegalArgumentException`...
  - 개발자 부주의로 발생하는 에러 
  
#### 예외의 종류 
  - Error: java.lang.Error의 서브 클래스
    - `OutOfMemory`, `ThreadDeth` ...
    - 주로 자바 VM에서 발생하는 것이므로 어플리케이션 코드에서 잡으려고 하면 안된다
    
    
  - Exception 과 체크 예외: java.lang.Exception 클래스와 서브클래스
    - 개발자들이 만든 애플리케이션 코드의 작업 중 예외가 발생한 경우
  
    
  - RuntimeException과 언체크/런타임 예외: java.lang.RuntimeException 
    - 개발자 부주의로 발생하는 에러 

#### 예외처리 방법
 - 예외 복구: 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려 놓는 것.
   - 예외 처리 코드를 강제하는 체크 예외가 해당된다
   - ex) 네트워크 에러 시 재접속 시도를 하는 경우


 - 예외처리 회피: 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것. `throw`
   - throws 문으로 선언해서 catch문으로 예외를 잡은 후 로그를 남기고 호출한 쪽으로 예외를 다시 던진다
   - ex) JdbcTemplate 콜백 오브젝트의 메서드는 SQLException 예외를 회피하고 템플릿 레벨에서 처리하도록 던진다
   

 - 예외전환: 예외를 정상적은 상태로 만들 수 없기 떄문에 예외를 메소드 밖으로 던지는 것(그대로 넘기는 것이 아니라 적절한 예외로 전환함) 
   - 내부에서 발생한 예외를 의미를 분명하게 해줄 수 있는 예외로 바꾸기 위해 사용
   - 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 것(wrap)
     - 주로 예외처리를 강제하는 체크 예외를 런타임예외로 바꾸어 사용한다
   

#### 예외 전환 주의할 점
 - 기술에 대한 예외가 각기 다름을 유의해야 한다
   - `jdbc`, `hibernate`, `jdo`...
 - 스프링이 내부적으로 DataAccessException 예외를 추상화하고 있기 때문에 기술에 독립적은 dao를 작성한다
 - 기술 독립적인 dao를 각각 구현하여 추상화된 예외를 전환하여 처리할 수 있다 


#### 정리 
 - 예외를 잡아서 아무런 조치ㄹ를 취하지 않거나 의미 없는 throws 선언은 위험하다
 - 예외를 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 한다
 - 좀 더 의미 예외로 변경하거나 불필요한 catch/throws를 피하기 위해 런타임 예외로 포장하는 두 가지 방법의 예외 전환이 있다
 - 복구할 수 없는 예외는 빨리 런타임 예외로 전환하는 것이 바람직하다
 - 애플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다
 - JDBC의 SQLException은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야한다
 - SQLException의 에러코드는 DB 종속적이기 떄문에 DB에 독립적인 예외로 전환이 필요하다
 - 스프링은 DataAccessException을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다
 - DAO를 데이터 액세스 기술에서 독립시키려면 인터페이스 도입과 런타임 예외전환, 기술 독립적 추상화된 예외 전환이 필요하다